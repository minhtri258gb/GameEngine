from bokeh import io as bok
from bokeh import plotting as bok_plot

EASE_LINEAR=lambda t: t
EASE_LINEAR=lambda t: t
EASE_IN_QUAD=lambda t: t*t
EASE_OUT_QUAD=lambda t: t*(2-t)
EASE_INOUT_QUAD=lambda t: 2*t*t if t<0.5 else -1+(4-2*t)*t
EASE_IN_CUBIC=lambda t: t*t*t
EASE_OUT_CUBIC=lambda t: (--t)*t*t+1
EASE_INOUT_CUBIC=lambda t: 4*t*t*t if t<0.5 else (t-1)*(2*t-2)*(2*t-2)+1
EASE_IN_QUART=lambda t: t*t*t*t
EASE_OUT_QUART=lambda t: 1-(--t)*t*t*t
EASE_INOUT_QUART=lambda t: 8*t*t*t*t if t<0.5 else 1-8*(--t)*t*t*t
EASE_IN_QUINT=lambda t: t*t*t*t*t
EASE_OUT_QUINT=lambda t: 1+(--t)*t*t*t*t
EASE_INOUT_QUINT=lambda t: 16*t*t*t*t*t if t<0.5 else 1+16*(--t)*t*t*t*t

def EASE_BEZIER(x1, y1, x2, y2):
    """Generates a bezier ease curve.

    Use the below site to choose params:
    http://greweb.me/bezier-easing-editor/example/
    """
    #TODO: implement
    return EASE_LINEAR

class _Keyframe(object):
    def __init__(self, frame_offset, end_value, transition=EASE_LINEAR):
        self.frame_offset = frame_offset
        self.end_value = end_value
        self.transition = transition

    def update_abs_values(self, start_frame, start_value):
        self.start_frame = start_frame
        self.end_frame = start_frame + self.frame_offset
        self.start_value = start_value

    def calc_transform(self, current_value, current_frame):
        start_frame = current_frame - self.start_frame
        end_frame = self.end_frame - self.start_frame
        t = self.transition(float(start_frame)/end_frame)
        out = t * (float(self.end_value) - self.start_value) + self.start_value
        return out - current_value

    def is_valid_for_frame(self, current_frame):
        return (current_frame > self.start_frame and current_frame <= self.end_frame)

class TransitionValue(object):
    """Defines a transition path that gets a value from a starting point to an ending point.

    The starting and ending points are known as "keyframes", and they describe
    the value that is to be arrived at and when it should arrive at that point.
    The values between the keyframes are then generated by an easing function,
    which gradually transition the value from point A to B over time.  In other
    words, this class basically constructs a mathematical piecewise function,
    where each keyframe forms one of the functions in the overall whole.
    """

    def __init__(self, start_frame, start_value):
        self.keyframes = []
        self.current_keyframe = None
        self.reset(start_frame, start_value)

    def reset(self, start_frame=None, start_value=None):
        if start_frame is not None:
            self.start_frame = start_frame

        if start_frame is not None:
            self.start_value = start_value

        # Update the absolute location values in each keyframe
        cur_offset = self.start_frame
        cur_value = self.start_value
        for keyframe in self.keyframes:
            keyframe.update_abs_values(cur_offset, cur_value)
            cur_offset += keyframe.frame_offset
            cur_value = keyframe.end_value
        self.end_frame = cur_offset

    def add_keyframe(self, frame_offset, end_value, transition=EASE_LINEAR):
        keyframe = _Keyframe(frame_offset, end_value, transition)
        self.keyframes.append(keyframe)

    def calc_transform(self, current_value, current_frame):
        # Check if the current frame we're calculating for is outside of the
        # frames we want to animate in
        if current_frame <= self.start_frame or current_frame > self.end_frame:
            return 0.0

        # Are we already using a valid keyframe?
        if self.current_keyframe is not None and self.keyframes[self.current_keyframe].is_valid_for_frame(current_frame):
            return self.keyframes[self.current_keyframe].calc_transform(current_value, current_frame)

        # Figure out what keyframe we should be on
        for i, keyframe in enumerate(self.keyframes):
            if keyframe.is_valid_for_frame(current_frame):
                self.current_keyframe = i
                break

        # Since at this point we're in animation range it's garunteed that
        # we'll find a keyframe for this frame in the previous operation.
        return self.keyframes[self.current_keyframe].calc_transform(current_value, current_frame)

def main():
    val = 10.0
    anim = TransitionValue(50, val)
    anim.add_keyframe(50, -5.0, EASE_INOUT_CUBIC)
    anim.add_keyframe(50, 20.0, EASE_INOUT_QUAD)
    anim.add_keyframe(50, 10.0, EASE_IN_QUINT)
    anim.add_keyframe(50, 20.0, EASE_LINEAR)
    anim.reset()

    x = [i for i in range(0, 301)]
    y = []
    for frame in x:
        val += anim.calc_transform(val, frame)
        y.append(val)

    p = bok_plot.figure(sizing_mode='stretch_both', title="Animation value transition")
    p.line(x, y)
    bok.show(p)

if __name__ == '__main__':
    main()
